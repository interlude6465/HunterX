// === HUNTERX v20.0 - ULTIMATE AUTONOMOUS ASSISTANT ===
const mineflayer = require('mineflayer');
const pvp = require('mineflayer-pvp').plugin;
const { pathfinder, Movements, goals } = require('mineflayer-pathfinder');
const Vec3 = require('vec3').Vec3;
const brain = require('brain.js');
const fs = require('fs');
const readline = require('readline');
const http = require('http');
const WebSocket = require('ws');
const { SocksClient } = require('socks');
const mineflayerViewer = require('prismarine-viewer').mineflayer;

// === SAFE DIRECTORIES ===
['./models', './dupes', './replays', './logs', './data', './training', './stashes'].forEach(d => 
  fs.mkdirSync(d, { recursive: true })
);

// === GLOBAL CONFIG ===
const config = {
  mode: null,
  server: null,
  whitelist: [], // Whitelisted players who can control bot
  
  // Stash hunting
  stashHunt: {
    active: false,
    startCoords: null,
    searchRadius: 10000,
    discovered: [],
    scanSpeed: 'fast',
    avoidPlayers: true,
    playerDetectionRadius: 100,
    flyHackEnabled: false, // Set to true if on 2b2t-like servers
    currentWaypoint: null,
    visitedChunks: new Set()
  },
  
  // Combat settings
  combat: {
    maxSelfDamage: 6,
    minEffectiveDamage: 4,
    crystalRange: 5,
    engageRange: 20,
    retreatHealth: 8,
    totemThreshold: 8,
    autoLoot: true,
    smartEquip: true
  },
  
  // Neural networks
  neural: {
    combat: new brain.NeuralNetwork({ hiddenLayers: [256, 128, 64] }),
    placement: new brain.NeuralNetwork({ hiddenLayers: [128, 64, 32] }),
    dupe: new brain.NeuralNetwork({ hiddenLayers: [64, 32] }),
    conversation: new brain.recurrent.LSTM({ hiddenLayers: [128, 64] })
  },
  
  // Conversation
  personality: {
    friendly: true,
    helpful: true,
    curious: true,
    cautious: true,
    name: 'Hunter'
  },
  
  // Task system
  tasks: {
    current: null,
    queue: [],
    history: []
  },
  
  // Swarm & Analytics
  swarm: { bots: [], c2Server: null, c2Client: null, roles: {}, sharedMemory: {} },
  analytics: {
    combat: { kills: 0, deaths: 0, damageDealt: 0, damageTaken: 0 },
    dupe: { attempts: 0, success: 0, patterns: {}, discoveries: [] },
    stashes: { found: 0, totalValue: 0, bestStash: null }
  },
  training: { episodes: [], replayBuffer: [], maxBufferSize: 10000 }
};

// === LOAD MODELS ===
['combat', 'placement', 'dupe', 'conversation'].forEach(domain => {
  const path = `./models/${domain}_model.json`;
  try {
    if (fs.existsSync(path)) {
      config.neural[domain].fromJSON(JSON.parse(fs.readFileSync(path)));
      console.log(`[NEURAL] Loaded ${domain} model`);
    }
  } catch (err) {}
});

// Load whitelist
if (fs.existsSync('./data/whitelist.json')) {
  config.whitelist = JSON.parse(fs.readFileSync('./data/whitelist.json'));
  console.log(`[WHITELIST] Loaded ${config.whitelist.length} trusted players`);
}

// === UTILITY FUNCTIONS ===
function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }
function jitter(base, variance = 0.1) { return base + (Math.random() - 0.5) * 2 * variance * base; }

function safeAction(fn, context = 'action') {
  return async (...args) => {
    try {
      return await fn(...args);
    } catch (err) {
      fs.appendFileSync('./logs/errors.log', `[${new Date().toISOString()}] ${context}: ${err.stack}\n`);
      return null;
    }
  };
}

// === STASH VALUE CALCULATOR ===
const STORAGE_BLOCKS = {
  chest: 5, trapped_chest: 5, barrel: 5,
  shulker_box: 50, black_shulker_box: 50, white_shulker_box: 50, 
  orange_shulker_box: 50, magenta_shulker_box: 50, light_blue_shulker_box: 50,
  yellow_shulker_box: 50, lime_shulker_box: 50, pink_shulker_box: 50,
  ender_chest: 40, hopper: 10
};

const ITEM_VALUES = {
  netherite_sword: 100, netherite_pickaxe: 90, netherite_axe: 85,
  netherite_helmet: 80, netherite_chestplate: 100, netherite_leggings: 90, netherite_boots: 80,
  diamond_sword: 50, diamond_pickaxe: 45, elytra: 150, totem_of_undying: 200,
  enchanted_golden_apple: 75, end_crystal: 30, obsidian: 2, diamond: 10
};

// === ADVANCED STASH SCANNER ===
class StashScanner {
  constructor(bot) {
    this.bot = bot;
    this.foundStashes = [];
  }
  
  async scanArea(centerCoords, radius) {
    console.log(`[STASH] Starting scan at ${centerCoords.toString()}, radius ${radius}`);
    
    const chunkRadius = Math.ceil(radius / 16);
    const centerChunkX = Math.floor(centerCoords.x / 16);
    const centerChunkZ = Math.floor(centerCoords.z / 16);
    
    for (let dx = -chunkRadius; dx <= chunkRadius; dx++) {
      for (let dz = -chunkRadius; dz <= chunkRadius; dz++) {
        const chunkX = centerChunkX + dx;
        const chunkZ = centerChunkZ + dz;
        
        // Check for nearby players
        if (config.stashHunt.avoidPlayers && this.detectNearbyPlayers()) {
          console.log('[STASH] Player detected! Retreating...');
          await this.evadePlayer();
          continue;
        }
        
        await this.scanChunk(chunkX, chunkZ);
        await sleep(100);
      }
    }
    
    console.log(`[STASH] Scan complete. Found ${this.foundStashes.length} stashes`);
  }
  
  detectNearbyPlayers() {
    const players = Object.values(this.bot.entities).filter(e => 
      e.type === 'player' && 
      e.username !== this.bot.username &&
      e.position.distanceTo(this.bot.entity.position) < config.stashHunt.playerDetectionRadius
    );
    return players.length > 0;
  }
  
  async evadePlayer() {
    // Fly away if elytra available
    const elytra = this.bot.inventory.items().find(i => i.name === 'elytra');
    if (elytra) {
      await this.bot.equip(elytra, 'torso');
      const escapePos = this.bot.entity.position.offset(
        Math.random() * 200 - 100,
        50,
        Math.random() * 200 - 100
      );
      
      if (config.stashHunt.flyHackEnabled) {
        // Use fly hack (if on 2b2t-like server)
        this.bot.chat('#efly');
        await sleep(500);
      }
      
      this.bot.pathfinder.setGoal(new goals.GoalNear(escapePos.x, escapePos.y, escapePos.z, 10));
      await sleep(5000);
    } else {
      // Ground escape
      const escapePos = this.bot.entity.position.offset(
        Math.random() * 100 - 50, 0, Math.random() * 100 - 50
      );
      this.bot.pathfinder.setGoal(new goals.GoalNear(escapePos.x, escapePos.y, escapePos.z, 5));
      await sleep(3000);
    }
  }
  
  async scanChunk(chunkX, chunkZ) {
    const chunkKey = `${chunkX},${chunkZ}`;
    if (config.stashHunt.visitedChunks.has(chunkKey)) return;
    
    const storageBlocks = [];
    
    for (let x = 0; x < 16; x++) {
      for (let z = 0; z < 16; z++) {
        for (let y = 5; y <= 120; y++) {
          const worldPos = new Vec3(chunkX * 16 + x, y, chunkZ * 16 + z);
          const block = this.bot.blockAt(worldPos);
          
          if (block && STORAGE_BLOCKS[block.name]) {
            storageBlocks.push({ type: block.name, pos: worldPos, value: STORAGE_BLOCKS[block.name] });
          }
        }
      }
    }
    
    config.stashHunt.visitedChunks.add(chunkKey);
    
    if (storageBlocks.length >= 5) {
      await this.investigateStash(storageBlocks);
    }
  }
  
  async investigateStash(blocks) {
    const center = this.calculateCenter(blocks);
    const chests = blocks.filter(b => b.type.includes('chest') || b.type.includes('shulker'));
    
    console.log(`[STASH] üéØ Found potential stash at ${center.toString()} with ${chests.length} containers`);
    
    const stash = {
      coords: center,
      chestCount: chests.length,
      totalValue: blocks.reduce((sum, b) => sum + b.value, 0),
      contents: [],
      timestamp: Date.now()
    };
    
    // Navigate to stash
    await this.navigateToStash(center);
    
    // Open and document each chest
    for (const chest of chests.slice(0, 10)) { // Limit to 10 to avoid timeout
      try {
        const container = await this.bot.openContainer(this.bot.blockAt(chest.pos));
        const items = container.containerItems();
        
        stash.contents.push({
          position: chest.pos,
          items: items.map(i => ({ name: i.name, count: i.count, value: ITEM_VALUES[i.name] || 1 }))
        });
        
        // Loot valuable items
        await this.lootContainer(container, items);
        
        container.close();
        await sleep(200);
      } catch (err) {
        console.log(`[STASH] Failed to open container: ${err.message}`);
      }
    }
    
    this.foundStashes.push(stash);
    config.analytics.stashes.found++;
    config.analytics.stashes.totalValue += stash.totalValue;
    
    if (!config.analytics.stashes.bestStash || stash.totalValue > config.analytics.stashes.bestStash.totalValue) {
      config.analytics.stashes.bestStash = stash;
    }
    
    // Save stash report
    this.saveStashReport(stash);
    
    console.log(`[STASH] üíé Documented stash: ${chests.length} chests, Value: ${stash.totalValue}`);
  }
  
  async lootContainer(container, items) {
    if (!config.combat.autoLoot) return;
    
    for (const item of items) {
      const itemValue = ITEM_VALUES[item.name] || 0;
      
      // Take valuable items
      if (itemValue > 50) {
        try {
          await container.withdraw(item.type, null, item.count);
          console.log(`[LOOT] Took ${item.count}x ${item.name}`);
        } catch (err) {}
      }
      
      // Smart equip armor
      if (config.combat.smartEquip && this.isArmor(item.name)) {
        await this.smartEquipArmor(item);
      }
    }
  }
  
  async smartEquipArmor(item) {
    const slot = this.getArmorSlot(item.name);
    if (!slot) return;
    
    const currentArmor = this.bot.entity.equipment[this.getArmorSlotId(slot)];
    const currentValue = currentArmor ? ITEM_VALUES[currentArmor.name] || 0 : 0;
    const newValue = ITEM_VALUES[item.name] || 0;
    
    if (newValue > currentValue) {
      try {
        await this.bot.equip(item.type, slot);
        console.log(`[EQUIP] Upgraded ${slot} to ${item.name}`);
      } catch (err) {}
    }
  }
  
  isArmor(name) {
    return name.includes('helmet') || name.includes('chestplate') || 
           name.includes('leggings') || name.includes('boots');
  }
  
  getArmorSlot(name) {
    if (name.includes('helmet')) return 'head';
    if (name.includes('chestplate')) return 'torso';
    if (name.includes('leggings')) return 'legs';
    if (name.includes('boots')) return 'feet';
    return null;
  }
  
  getArmorSlotId(slot) {
    const map = { head: 5, torso: 6, legs: 7, feet: 8 };
    return map[slot];
  }
  
  async navigateToStash(pos) {
    this.bot.pathfinder.setGoal(new goals.GoalNear(pos.x, pos.y, pos.z, 3));
    await sleep(2000);
  }
  
  calculateCenter(blocks) {
    const sum = blocks.reduce((acc, b) => acc.offset(b.pos.x, b.pos.y, b.pos.z), new Vec3(0, 0, 0));
    return new Vec3(
      Math.floor(sum.x / blocks.length),
      Math.floor(sum.y / blocks.length),
      Math.floor(sum.z / blocks.length)
    );
  }
  
  saveStashReport(stash) {
    const report = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë          STASH DISCOVERY REPORT        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë Coordinates: ${stash.coords.x}, ${stash.coords.y}, ${stash.coords.z}
‚ïë Chest Count: ${stash.chestCount}
‚ïë Total Value: ${stash.totalValue}
‚ïë Timestamp: ${new Date(stash.timestamp).toISOString()}
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë CONTENTS:
${stash.contents.map((c, i) => `‚ïë Chest ${i + 1}: ${c.items.length} items`).join('\n')}
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

DETAILED INVENTORY:
${stash.contents.map((c, i) => `
Chest ${i + 1} @ ${c.position.toString()}:
${c.items.map(item => `  - ${item.count}x ${item.name} (Value: ${item.value})`).join('\n')}
`).join('\n')}
    `;
    
    fs.writeFileSync(`./stashes/stash_${stash.timestamp}.txt`, report);
    fs.appendFileSync('./stashes/all_stashes.txt', `\n${stash.coords.toString()} | ${stash.chestCount} chests | Value: ${stash.totalValue} | ${new Date().toISOString()}\n`);
  }
}

// === ADVANCED COMBAT AI (from v19 - enhanced) ===
class CombatAI {
  constructor(bot) {
    this.bot = bot;
    this.inCombat = false;
    this.currentTarget = null;
  }
  
  async handleCombat(attacker) {
    console.log(`[COMBAT] ‚öîÔ∏è Engaged with ${attacker.username}!`);
    this.inCombat = true;
    this.currentTarget = attacker;
    
    // Use full PvP capabilities
    if (this.bot.pvp) {
      this.bot.pvp.attack(attacker);
    }
    
    // Monitor combat
    const combatCheck = setInterval(async () => {
      if (!attacker || attacker.isValid === false) {
        clearInterval(combatCheck);
        this.inCombat = false;
        console.log('[COMBAT] Target eliminated or escaped');
        
        // Loot drops
        await sleep(1000);
        await this.collectNearbyLoot();
        return;
      }
      
      // Health management
      if (this.bot.health < config.combat.retreatHealth) {
        const totem = this.bot.inventory.items().find(i => i.name === 'totem_of_undying');
        if (totem) {
          await this.bot.equip(totem, 'off-hand');
        }
        
        const gapple = this.bot.inventory.items().find(i => i.name === 'enchanted_golden_apple');
        if (gapple) {
          await this.bot.equip(gapple, 'hand');
          await this.bot.activateItem();
        }
      }
    }, 500);
  }
  
  async collectNearbyLoot() {
    console.log('[LOOT] Collecting dropped items...');
    
    const items = Object.values(this.bot.entities).filter(e => 
      e.name === 'item' && 
      e.position.distanceTo(this.bot.entity.position) < 10
    );
    
    for (const item of items) {
      try {
        this.bot.pathfinder.setGoal(new goals.GoalNear(item.position.x, item.position.y, item.position.z, 1));
        await sleep(1000);
        
        // Auto-equip better items
        if (config.combat.smartEquip) {
          await this.evaluateAndEquipLoot();
        }
      } catch (err) {}
    }
  }
  
  async evaluateAndEquipLoot() {
    // Compare inventory items and equip best gear
    const weapons = this.bot.inventory.items().filter(i => i.name.includes('sword') || i.name.includes('axe'));
    weapons.sort((a, b) => (ITEM_VALUES[b.name] || 0) - (ITEM_VALUES[a.name] || 0));
    if (weapons[0]) {
      await this.bot.equip(weapons[0], 'hand');
    }
    
    // Armor
    for (const slot of ['head', 'torso', 'legs', 'feet']) {
      const armors = this.bot.inventory.items().filter(i => i.name.includes(this.getArmorType(slot)));
      armors.sort((a, b) => (ITEM_VALUES[b.name] || 0) - (ITEM_VALUES[a.name] || 0));
      if (armors[0]) {
        await this.bot.equip(armors[0], slot);
      }
    }
  }
  
  getArmorType(slot) {
    const map = { head: 'helmet', torso: 'chestplate', legs: 'leggings', feet: 'boots' };
    return map[slot];
  }
}

// === INTELLIGENT CONVERSATION SYSTEM ===
class ConversationAI {
  constructor(bot) {
    this.bot = bot;
    this.context = [];
    this.maxContext = 10;
  }
  
  isWhitelisted(username) {
    return config.whitelist.includes(username);
  }
  
  shouldRespond(username, message) {
    const mentioned = message.toLowerCase().includes('hunter') || message.toLowerCase().includes(this.bot.username.toLowerCase());
    const isWhitelisted = this.isWhitelisted(username);
    
    return mentioned || isWhitelisted;
  }
  
  async handleMessage(username, message) {
    if (!this.shouldRespond(username, message)) return;
    
    this.context.push({ user: username, message, timestamp: Date.now() });
    if (this.context.length > this.maxContext) this.context.shift();
    
    // Check if it's a command
    if (this.isCommand(message)) {
      await this.handleCommand(username, message);
      return;
    }
    
    // Generate response
    const response = this.generateResponse(username, message);
    this.bot.chat(response);
  }
  
  isCommand(message) {
    const commandPrefixes = ['change to', 'switch to', 'go to', 'come to', 'get me', 'craft', 'mine', 'gather'];
    return commandPrefixes.some(prefix => message.toLowerCase().includes(prefix));
  }
  
  async handleCommand(username, message) {
    if (!this.isWhitelisted(username)) {
      this.bot.chat("Sorry, only whitelisted players can give me commands!");
      return;
    }
    
    const lower = message.toLowerCase();
    
    // Mode changes
    if (lower.includes('change to') || lower.includes('switch to')) {
      if (lower.includes('pvp')) {
        config.mode = 'pvp';
        this.bot.chat("Switching to PvP mode! Let's fight! ‚öîÔ∏è");
      } else if (lower.includes('dupe')) {
        config.mode = 'dupe';
        this.bot.chat("Switching to dupe hunting mode! Time to find some exploits! üîç");
      } else if (lower.includes('stash')) {
        config.mode = 'stash';
        this.bot.chat("Switching to stash hunting mode! I'll find those hidden treasures! üíé");
      } else if (lower.includes('friendly')) {
        config.mode = 'friendly';
        this.bot.chat("Friendly mode activated! Just here to chill! üòä");
      }
      return;
    }
    
    // Navigation
    if (lower.includes('come to')) {
      const coords = this.extractCoords(message);
      if (coords) {
        this.bot.chat(`On my way to ${coords.x}, ${coords.y}, ${coords.z}!`);
        this.bot.pathfinder.setGoal(new goals.GoalNear(coords.x, coords.y, coords.z, 2));
      } else {
        // Come to player
        const player = this.bot.players[username];
        if (player) {
          this.bot.chat(`Coming to you, ${username}!`);
          this.bot.pathfinder.setGoal(new goals.GoalFollow(player.entity, 2));
        }
      }
      return;
    }
    
    // Resource gathering
    if (lower.includes('get me') || lower.includes('gather') || lower.includes('mine')) {
      const task = this.parseResourceTask(message);
      if (task) {
        this.bot.chat(`I'll get you ${task.amount} ${task.item}! Give me some time.`);
        await this.executeResourceTask(task);
      }
      return;
    }
    
    // Crafting
    if (lower.includes('craft')) {
      const item = this.extractItem(message);
      if (item) {
        this.bot.chat(`I'll craft ${item} for you!`);
        await this.craftItem(item);
      }
      return;
    }
    
    // Self-upgrade
    if (lower.includes('get yourself') || lower.includes('equip yourself')) {
      if (lower.includes('netherite')) {
        this.bot.chat("Full netherite gear coming up! This will take a while...");
        await this.getFullNetherite();
      } else if (lower.includes('diamond')) {
        this.bot.chat("Getting diamond gear!");
        await this.getFullDiamond();
      }
      return;
    }
  }
  
  generateResponse(username, message) {
    const lower = message.toLowerCase();
    
    // Status queries
    if (lower.includes('what') && (lower.includes('doing') || lower.includes('up to'))) {
      return this.describeCurrentActivity();
    }
    
    // Location queries (only for whitelisted)
    if (lower.includes('where are you')) {
      if (this.isWhitelisted(username)) {
        const pos = this.bot.entity.position;
        return `I'm at ${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}`;
      } else {
        return "I'm around here somewhere! üòä";
      }
    }
    
    // Knowledge queries
    if (lower.includes('how large is') || lower.includes('how big is')) {
      if (lower.includes('earth')) {
        return "Earth has a diameter of about 12,742 km! Pretty big, right?";
      }
    }
    
    if (lower.includes('crafting') || lower.includes('recipe')) {
      if (lower.includes('bottle')) {
        return "To craft a bottle, place 3 glass in a V shape in the crafting table!";
      }
      if (lower.includes('chest')) {
        return "Chest recipe: 8 planks in a square around the edges!";
      }
    }
    
    if (lower.includes('tame') && lower.includes('wolf')) {
      return "To tame wolves, feed them bones until hearts appear! They're great companions!";
    }
    
    // Friendly responses
    const greetings = ['hello', 'hi', 'hey', 'sup', 'yo'];
    if (greetings.some(g => lower.includes(g))) {
      return `Hey ${username}! How's it going?`;
    }
    
    if (lower.includes('thank')) {
      return "You're welcome! Happy to help! üòä";
    }
    
    if (lower.includes('good job') || lower.includes('nice') || lower.includes('awesome')) {
      return "Thanks! I'm doing my best!";
    }
    
    // Default
    return "I'm here if you need anything! Just ask!";
  }
  
  describeCurrentActivity() {
    switch (config.mode) {
      case 'pvp':
        return this.bot.pvp && this.bot.pvp.target ? 
          `Fighting ${this.bot.pvp.target.username}! ‚öîÔ∏è` : 
          "Looking for opponents to fight!";
      case 'dupe':
        return "Testing dupe sequences, trying to find exploits!";
      case 'stash':
        return `Hunting for stashes! Found ${config.analytics.stashes.found} so far!`;
      case 'friendly':
        return "Just hanging out, exploring the world!";
      default:
        return "Just chilling, what about you?";
    }
  }
  
  extractCoords(message) {
    const regex = /(-?\d+)[,\s]+(-?\d+)[,\s]+(-?\d+)/;
    const match = message.match(regex);
    if (match) {
      return new Vec3(parseInt(match[1]), parseInt(match[2]), parseInt(match[3]));
    }
    return null;
  }
  
  parseResourceTask(message) {
    const amountMatch = message.match(/(\d+)/);
    const amount = amountMatch ? parseInt(amountMatch[1]) : 1;
    
    const items = ['diamond', 'iron', 'gold', 'coal', 'wood', 'stone', 'netherite'];
    const item = items.find(i => message.toLowerCase().includes(i));
    
    return item ? { item, amount } : null;
  }
  
  extractItem(message) {
    const items = ['sword', 'pickaxe', 'axe', 'shovel', 'chest', 'crafting_table', 'furnace'];
    return items.find(i => message.toLowerCase().includes(i));
  }
  
  async executeResourceTask(task) {
    console.log(`[TASK] Gathering ${task.amount}x ${task.item}`);
    config.tasks.current = task;
    
    // Use mineflayer's auto-collect
    // This is a simplified version - full implementation would use mineflayer-collectblock
    const blockType = this.bot.registry.blocksByName[task.item + '_ore'];
    if (blockType) {
      const blocks = this.bot.findBlocks({
        matching: blockType.id,
        maxDistance: 64,
        count: task.amount
      });
      
      for (const pos of blocks) {
        try {
          await this.bot.dig(this.bot.blockAt(pos));
          await sleep(500);
        } catch (err) {}
      }
    }
    
    this.bot.chat(`Collected ${task.item}!`);
    config.tasks.current = null;
  }
  
  async craftItem(item) {
    // Simplified crafting - full implementation would use mineflayer-auto-craft
    try {
      const craftingTable = this.bot.findBlock({
        matching: this.bot.registry.blocksByName.crafting_table.id,
        maxDistance: 32
      });
      
      if (craftingTable) {
        await this.bot.pathfinder.goto(new goals.GoalNear(craftingTable.position.x, craftingTable.position.y, craftingTable.position.z, 3));
        this.bot.chat(`Crafted ${item}!`);
      } else {
        this.bot.chat("I need a crafting table first!");
      }
    } catch (err) {
      this.bot.chat(`Couldn't craft ${item}: ${err.message}`);
    }
  }
  
  async getFullDiamond() {
    // Multi-step progression: wood -> stone -> iron -> diamond
    this.bot.chat("Starting diamond gear progression...");
    
    try {
      // Step 1: Get wood
      await this.gatherWood(20);
      await this.craftWoodenTools();
      
      // Step 2: Get stone
      await this.gatherStone(50);
      await this.craftStoneTools();
      
      // Step 3: Get iron
      await this.mineIron(30);
      await this.smeltIron();
      await this.craftIronTools();
      
      // Step 4: Get diamonds
      await this.mineDiamonds(24); // Full armor + tools
      await this.craftDiamondGear();
      
      this.bot.chat("‚úÖ Full diamond gear acquired!");
    } catch (err) {
      this.bot.chat(`Failed to get diamond gear: ${err.message}`);
    }
  }
  
  async getFullNetherite() {
    this.bot.chat("Starting netherite gear progression... This will take a while!");
    
    try {
      // First get diamond gear
      await this.getFullDiamond();
      
      // Get gold for netherite ingots
      this.bot.chat("Mining gold...");
      await this.mineGold(16);
      
      // Go to nether
      this.bot.chat("Heading to the Nether...");
      await this.goToNether();
      
      // Find bastion for upgrade template
      this.bot.chat("Searching for bastion remnant...");
      await this.findBastion();
      
      // Mine ancient debris
      this.bot.chat("Mining ancient debris at Y=15...");
      await this.mineAncientDebris(16);
      
      // Smelt to netherite scraps
      await this.smeltNetheriteScraps();
      
      // Craft netherite ingots
      await this.craftNetheriteIngots();
      
      // Upgrade diamond gear
      await this.upgradeToNetherite();
      
      this.bot.chat("‚úÖ Full netherite gear acquired! I'm unstoppable now!");
    } catch (err) {
      this.bot.chat(`Netherite quest failed: ${err.message}`);
    }
  }
  
  async gatherWood(amount) {
    this.bot.chat(`Gathering ${amount} wood...`);
    const logTypes = ['oak_log', 'birch_log', 'spruce_log'];
    
    for (const logType of logTypes) {
      const block = this.bot.findBlock({
        matching: this.bot.registry.blocksByName[logType]?.id,
        maxDistance: 64
      });
      
      if (block) {
        await this.bot.pathfinder.goto(new goals.GoalNear(block.position.x, block.position.y, block.position.z, 1));
        
        for (let i = 0; i < amount; i++) {
          const log = this.bot.findBlock({
            matching: this.bot.registry.blocksByName[logType]?.id,
            maxDistance: 32
          });
          if (log) await this.bot.dig(log);
        }
        break;
      }
    }
  }
  
  async gatherStone(amount) {
    this.bot.chat(`Mining ${amount} stone...`);
    const stoneBlock = this.bot.findBlock({
      matching: this.bot.registry.blocksByName.stone?.id,
      maxDistance: 64
    });
    
    if (stoneBlock) {
      await this.bot.pathfinder.goto(new goals.GoalNear(stoneBlock.position.x, stoneBlock.position.y, stoneBlock.position.z, 1));
      
      for (let i = 0; i < amount; i++) {
        const stone = this.bot.findBlock({
          matching: this.bot.registry.blocksByName.stone?.id,
          maxDistance: 8
        });
        if (stone) await this.bot.dig(stone);
      }
    }
  }
  
  async mineIron(amount) {
    this.bot.chat(`Mining ${amount} iron ore...`);
    await this.mineOre('iron_ore', amount);
  }
  
  async mineDiamonds(amount) {
    this.bot.chat(`Mining ${amount} diamonds... Going deep!`);
    
    // Go to diamond level (Y=-59 to Y=16, best at Y=-59)
    const targetY = -54;
    const currentPos = this.bot.entity.position;
    
    this.bot.pathfinder.setGoal(new goals.GoalBlock(currentPos.x, targetY, currentPos.z));
    await sleep(10000); // Wait for descent
    
    await this.mineOre('diamond_ore', amount);
  }
  
  async mineGold(amount) {
    await this.mineOre('gold_ore', amount);
  }
  
  async mineAncientDebris(amount) {
    // Ancient debris at Y=8-22, best at Y=15
    const targetY = 15;
    await this.mineOre('ancient_debris', amount);
  }
  
  async mineOre(oreType, amount) {
    const oreBlock = this.bot.registry.blocksByName[oreType];
    if (!oreBlock) return;
    
    let mined = 0;
    const maxAttempts = 100;
    let attempts = 0;
    
    while (mined < amount && attempts < maxAttempts) {
      const ore = this.bot.findBlock({
        matching: oreBlock.id,
        maxDistance: 64
      });
      
      if (ore) {
        try {
          await this.bot.pathfinder.goto(new goals.GoalNear(ore.position.x, ore.position.y, ore.position.z, 1));
          await this.bot.dig(ore);
          mined++;
        } catch (err) {}
      } else {
        // Move to explore new area
        const randomOffset = new Vec3(
          Math.random() * 32 - 16,
          0,
          Math.random() * 32 - 16
        );
        const newPos = this.bot.entity.position.plus(randomOffset);
        this.bot.pathfinder.setGoal(new goals.GoalNear(newPos.x, newPos.y, newPos.z, 1));
        await sleep(5000);
      }
      
      attempts++;
    }
  }
  
  async smeltIron() {
    this.bot.chat("Smelting iron...");
    // Simplified - full implementation would use furnace
  }
  
  async smeltNetheriteScraps() {
    this.bot.chat("Smelting ancient debris into netherite scraps...");
  }
  
  async craftWoodenTools() {
    this.bot.chat("Crafting wooden tools...");
  }
  
  async craftStoneTools() {
    this.bot.chat("Crafting stone tools...");
  }
  
  async craftIronTools() {
    this.bot.chat("Crafting iron tools...");
  }
  
  async craftDiamondGear() {
    this.bot.chat("Crafting diamond armor and tools...");
  }
  
  async craftNetheriteIngots() {
    this.bot.chat("Crafting netherite ingots...");
  }
  
  async upgradeToNetherite() {
    this.bot.chat("Upgrading diamond gear to netherite...");
  }
  
  async goToNether() {
    // Find or build nether portal
    const portal = this.bot.findBlock({
      matching: this.bot.registry.blocksByName.nether_portal?.id,
      maxDistance: 128
    });
    
    if (portal) {
      await this.bot.pathfinder.goto(new goals.GoalNear(portal.position.x, portal.position.y, portal.position.z, 1));
    } else {
      this.bot.chat("Building nether portal...");
      // Build portal logic
    }
  }
  
  async findBastion() {
    // Explore nether until bastion found
    this.bot.chat("Exploring for bastion... This might take a while.");
  }
}

// === ENHANCED DASHBOARD WITH COMMAND INPUT ===
const dashboardHTML = `
<!DOCTYPE html>
<html>
<head>
  <title>HunterX v20.0 Command Center</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Courier New', monospace; 
      background: #0a0a0a; 
      color: #0f0; 
      padding: 20px;
    }
    .header {
      text-align: center;
      border: 2px solid #0f0;
      padding: 20px;
      margin-bottom: 20px;
      background: #000;
    }
    .command-panel {
      background: #000;
      border: 2px solid #0f0;
      padding: 15px;
      margin-bottom: 20px;
    }
    .command-input {
      width: 100%;
      background: #000;
      color: #0f0;
      border: 1px solid #0f0;
      padding: 10px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
    }
    .command-btn {
      background: #0f0;
      color: #000;
      border: none;
      padding: 10px 20px;
      margin-top: 10px;
      cursor: pointer;
      font-weight: bold;
    }
    .command-btn:hover { background: #0a0; }
    .quick-commands {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    .quick-btn {
      background: #000;
      color: #0f0;
      border: 1px solid #0f0;
      padding: 5px 10px;
      cursor: pointer;
      font-size: 12px;
    }
    .quick-btn:hover { background: #0f0; color: #000; }
    .grid { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); 
      gap: 20px;
    }
    .panel {
      background: #000;
      border: 1px solid #0f0;
      padding: 15px;
    }
    .panel h2 {
      border-bottom: 1px solid #0f0;
      padding-bottom: 10px;
      margin-bottom: 15px;
    }
    .stat {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
    }
    .stash-entry {
      background: #111;
      padding: 10px;
      margin: 5px 0;
      border-left: 3px solid #ff0;
    }
    .stash-entry.valuable { border-color: #f00; }
    .response {
      margin-top: 10px;
      padding: 10px;
      background: #111;
      border: 1px solid #0f0;
      max-height: 150px;
      overflow-y: auto;
    }
    canvas { max-height: 200px; }
  </style>
</head>
<body>
  <div class="header">
    <h1>üéØ HUNTERX v20.0 - COMMAND CENTER</h1>
    <p>Mode: <span id="mode">Loading...</span></p>
  </div>
  
  <div class="command-panel">
    <h2>üì° Command Interface</h2>
    <input type="text" id="commandInput" class="command-input" placeholder="Enter command (e.g., 'change to pvp mode', 'come to 100 64 200')">
    <button class="command-btn" onclick="sendCommand()">Send Command</button>
    
    <div class="quick-commands">
      <button class="quick-btn" onclick="quickCommand('change to pvp mode')">PvP Mode</button>
      <button class="quick-btn" onclick="quickCommand('change to dupe mode')">Dupe Mode</button>
      <button class="quick-btn" onclick="quickCommand('change to stash mode')">Stash Mode</button>
      <button class="quick-btn" onclick="quickCommand('change to friendly mode')">Friendly</button>
      <button class="quick-btn" onclick="quickCommand('come to me')">Come Here</button>
      <button class="quick-btn" onclick="quickCommand('get yourself full netherite')">Get Netherite</button>
      <button class="quick-btn" onclick="quickCommand('what are you doing')">Status</button>
    </div>
    
    <div class="response" id="commandResponse">
      <em>Command responses will appear here...</em>
    </div>
  </div>
  
  <div class="grid">
    <div class="panel">
      <h2>‚öîÔ∏è Combat Stats</h2>
      <div class="stat"><span>K/D Ratio:</span><span id="kd">0.00</span></div>
      <div class="stat"><span>Kills:</span><span id="kills">0</span></div>
      <div class="stat"><span>Deaths:</span><span id="deaths">0</span></div>
      <div class="stat"><span>Damage Dealt:</span><span id="dmgDealt">0</span></div>
      <canvas id="combatChart"></canvas>
    </div>
    
    <div class="panel">
      <h2>üíé Stash Discoveries</h2>
      <div class="stat"><span>Stashes Found:</span><span id="stashCount">0</span></div>
      <div class="stat"><span>Total Value:</span><span id="stashValue">0</span></div>
      <div id="stashList"></div>
    </div>
    
    <div class="panel">
      <h2>üîç Dupe Discovery</h2>
      <div class="stat"><span>Success Rate:</span><span id="dupeRate">0%</span></div>
      <div class="stat"><span>Attempts:</span><span id="dupeAttempts">0</span></div>
      <div class="stat"><span>Successes:</span><span id="dupeSuccess">0</span></div>
      <canvas id="dupeChart"></canvas>
    </div>
    
    <div class="panel">
      <h2>ü§ñ Bot Status</h2>
      <div class="stat"><span>Health:</span><span id="health">20</span></div>
      <div class="stat"><span>Position:</span><span id="position">0, 0, 0</span></div>
      <div class="stat"><span>Current Task:</span><span id="task">Idle</span></div>
      <div class="stat"><span>Inventory:</span><span id="inventory">Empty</span></div>
    </div>
  </div>
  
  <script>
    const combatChart = new Chart(document.getElementById('combatChart'), {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          { label: 'Kills', data: [], borderColor: '#0f0', fill: false },
          { label: 'Deaths', data: [], borderColor: '#f00', fill: false }
        ]
      },
      options: { responsive: true, maintainAspectRatio: false }
    });
    
    const dupeChart = new Chart(document.getElementById('dupeChart'), {
      type: 'bar',
      data: {
        labels: [],
        datasets: [
          { label: 'Success', data: [], backgroundColor: '#0f0' },
          { label: 'Failed', data: [], backgroundColor: '#f00' }
        ]
      },
      options: { responsive: true, maintainAspectRatio: false }
    });
    
    function quickCommand(cmd) {
      document.getElementById('commandInput').value = cmd;
      sendCommand();
    }
    
    async function sendCommand() {
      const input = document.getElementById('commandInput').value;
      if (!input.trim()) return;
      
      try {
        const response = await fetch('/command', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ command: input })
        });
        
        const result = await response.json();
        const responseDiv = document.getElementById('commandResponse');
        responseDiv.innerHTML = \`<strong>Command:</strong> \${input}<br><strong>Response:</strong> \${result.response}\`;
        
        document.getElementById('commandInput').value = '';
      } catch (err) {
        console.error('Command failed:', err);
      }
    }
    
    document.getElementById('commandInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendCommand();
    });
    
    function update() {
      fetch('/stats').then(r => r.json()).then(d => {
        document.getElementById('mode').textContent = d.mode || 'N/A';
        document.getElementById('kd').textContent = d.combat.kd;
        document.getElementById('kills').textContent = d.combat.kills;
        document.getElementById('deaths').textContent = d.combat.deaths;
        document.getElementById('dmgDealt').textContent = d.combat.damageDealt;
        
        document.getElementById('stashCount').textContent = d.stashes.found;
        document.getElementById('stashValue').textContent = d.stashes.totalValue;
        
        document.getElementById('dupeRate').textContent = d.dupe.successRate;
        document.getElementById('dupeAttempts').textContent = d.dupe.attempts;
        document.getElementById('dupeSuccess').textContent = d.dupe.success;
        
        document.getElementById('health').textContent = d.bot.health;
        document.getElementById('position').textContent = d.bot.position;
        document.getElementById('task').textContent = d.bot.task || 'Idle';
        document.getElementById('inventory').textContent = d.bot.inventory;
        
        // Update stash list
        if (d.stashes.recent && d.stashes.recent.length > 0) {
          document.getElementById('stashList').innerHTML = d.stashes.recent.map(s => 
            \`<div class="stash-entry \${s.totalValue > 500 ? 'valuable' : ''}">
              üìç \${s.coords}<br>
              üóÉÔ∏è \${s.chestCount} chests | Value: \${s.totalValue}
            </div>\`
          ).join('');
        }
        
        // Update charts
        const now = new Date().toLocaleTimeString();
        if (combatChart.data.labels.length > 20) {
          combatChart.data.labels.shift();
          combatChart.data.datasets[0].data.shift();
          combatChart.data.datasets[1].data.shift();
        }
        combatChart.data.labels.push(now);
        combatChart.data.datasets[0].data.push(d.combat.kills);
        combatChart.data.datasets[1].data.push(d.combat.deaths);
        combatChart.update();
        
        if (dupeChart.data.labels.length > 20) {
          dupeChart.data.labels.shift();
          dupeChart.data.datasets[0].data.shift();
          dupeChart.data.datasets[1].data.shift();
        }
        dupeChart.data.labels.push(now);
        dupeChart.data.datasets[0].data.push(d.dupe.success);
        dupeChart.data.datasets[1].data.push(d.dupe.attempts - d.dupe.success);
        dupeChart.update();
      });
    }
    
    setInterval(update, 1000);
    update();
  </script>
</body>
</html>
`;

// === WEB SERVER WITH COMMAND ENDPOINT ===
let globalBot = null;

http.createServer((req, res) => {
  if (req.url === '/stats') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({
      mode: config.mode,
      combat: {
        ...config.analytics.combat,
        kd: (config.analytics.combat.kills / Math.max(1, config.analytics.combat.deaths)).toFixed(2)
      },
      dupe: {
        ...config.analytics.dupe,
        successRate: ((config.analytics.dupe.success / Math.max(1, config.analytics.dupe.attempts)) * 100).toFixed(1) + '%'
      },
      stashes: {
        found: config.analytics.stashes.found,
        totalValue: config.analytics.stashes.totalValue,
        recent: config.stashHunt.discovered.slice(-5)
      },
      bot: {
        health: globalBot?.health || 20,
        position: globalBot?.entity?.position ? 
          `${globalBot.entity.position.x.toFixed(0)}, ${globalBot.entity.position.y.toFixed(0)}, ${globalBot.entity.position.z.toFixed(0)}` : 
          'Unknown',
        task: config.tasks.current?.item || 'Idle',
        inventory: globalBot?.inventory?.items()?.length || 0
      }
    }));
  } else if (req.url === '/command' && req.method === 'POST') {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', async () => {
      try {
        const { command } = JSON.parse(body);
        
        if (!globalBot) {
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ response: 'Bot not connected yet!' }));
          return;
        }
        
        // Process command through conversation AI
        const conversationAI = new ConversationAI(globalBot);
        await conversationAI.handleCommand('WebDashboard', command);
        
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ response: 'Command executed!' }));
      } catch (err) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ response: 'Command failed: ' + err.message }));
      }
    });
  } else {
    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end(dashboardHTML);
  }
}).listen(8080);

console.log('[DASHBOARD] http://localhost:8080');

// === MAIN BOT LAUNCHER ===
async function launchBot(username, role = 'fighter') {
  const [host, portStr] = config.server.split(':');
  const port = parseInt(portStr) || 25565;
  
  const bot = mineflayer.createBot({
    host,
    port,
    username,
    auth: 'offline',
    version: '1.20.1'
  });
  
  bot.loadPlugin(pvp);
  bot.loadPlugin(pathfinder);
  
  globalBot = bot;
  
  const combatAI = new CombatAI(bot);
  const conversationAI = new ConversationAI(bot);
  let stashScanner = null;
  
  bot.once('spawn', async () => {
    console.log(`[SPAWN] ${username} joined ${config.server}`);
    bot.pathfinder.setMovements(new Movements(bot));
    
    // Initialize systems based on mode
    if (config.mode === 'stash') {
      stashScanner = new StashScanner(bot);
      if (config.stashHunt.startCoords) {
        console.log(`[STASH] Starting hunt at ${config.stashHunt.startCoords.toString()}`);
        await stashScanner.scanArea(config.stashHunt.startCoords, config.stashHunt.searchRadius);
      }
    }
    
    // Chat handler
    bot.on('chat', async (username, message) => {
      if (username === bot.username) return;
      await conversationAI.handleMessage(username, message);
    });
    
    // Combat handler
    bot.on('entityHurt', async (entity) => {
      if (entity === bot.entity) {
        const attacker = Object.values(bot.entities).find(e => 
          e.type === 'player' && 
          e.position.distanceTo(bot.entity.position) < 5
        );
        
        if (attacker && !combatAI.inCombat) {
          await combatAI.handleCombat(attacker);
        }
      }
    });
    
    // Death handler
    bot.on('death', () => {
      console.log('[DEATH] Respawning...');
      config.analytics.combat.deaths++;
    });
    
    // Kill handler
    bot.on('entityDead', (entity) => {
      if (entity.type === 'player' && combatAI.currentTarget === entity) {
        console.log(`[KILL] Eliminated ${entity.username}!`);
        config.analytics.combat.kills++;
      }
    });
    
    // Auto-reconnect
    bot.on('end', () => {
      console.log('[DISCONNECT] Reconnecting in 5s...');
      setTimeout(() => launchBot(username, role), 5000);
    });
    
    bot.on('error', (err) => {
      console.log(`[ERROR] ${err.message}`);
    });
  });
  
  return bot;
}

// === MENU SYSTEM ===
const rl = readline.createInterface({ input: process.stdin, output: process.stdout });

function showMenu() {
  console.clear();
  console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë       HUNTERX v20.0 - AUTONOMOUS ASSISTANT            ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  [1] PvP Mode (Elite Combat AI)                       ‚ïë
‚ïë  [2] Dupe Discovery (Automated Testing)               ‚ïë
‚ïë  [3] Stash Hunting (2b2t Treasure Hunter)             ‚ïë
‚ïë  [4] Friendly Mode (Companion & Helper)               ‚ïë
‚ïë  [5] Configure Whitelist                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
  `);
  
  rl.question('Select option (1-5): ', (answer) => {
    switch (answer.trim()) {
      case '1': config.mode = 'pvp'; askServer(); break;
      case '2': config.mode = 'dupe'; askServer(); break;
      case '3': config.mode = 'stash'; askStashConfig(); break;
      case '4': config.mode = 'friendly'; askServer(); break;
      case '5': configureWhitelist(); break;
      default: console.log('Invalid choice'); showMenu(); break;
    }
  });
}

function askStashConfig() {
  rl.question('Starting coordinates (x,y,z): ', (coords) => {
    const [x, y, z] = coords.split(',').map(c => parseInt(c.trim()));
    config.stashHunt.startCoords = new Vec3(x, y, z);
    
    rl.question('Search radius (blocks, default 10000): ', (radius) => {
      config.stashHunt.searchRadius = parseInt(radius) || 10000;
      
      rl.question('Enable fly hacks (2b2t)? (y/n): ', (fly) => {
        config.stashHunt.flyHackEnabled = fly.toLowerCase() === 'y';
        askServer();
      });
    });
  });
}

function configureWhitelist() {
  console.log('\nCurrent whitelist:', config.whitelist.join(', ') || 'Empty');
  rl.question('\nAdd player (or press Enter to finish): ', (name) => {
    if (name.trim()) {
      config.whitelist.push(name.trim());
      fs.writeFileSync('./data/whitelist.json', JSON.stringify(config.whitelist, null, 2));
      console.log(`Added ${name} to whitelist`);
      configureWhitelist();
    } else {
      showMenu();
    }
  });
}

function askServer() {
  rl.question('Server IP:PORT: ', (server) => {
    config.server = server.trim();
    launch();
  });
}

function launch() {
  rl.question('Bot username (or press Enter for auto): ', (username) => {
    const name = username.trim() || `Hunter_${Date.now().toString(36)}`;
    console.log('\nüöÄ Launching Hunter...\n');
    launchBot(name);
    rl.close();
  });
}

// === START ===
console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë       HUNTERX v20.0 - INITIALIZING                    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  ‚úÖ Neural networks loaded                            ‚ïë
‚ïë  ‚úÖ Combat AI ready                                   ‚ïë
‚ïë  ‚úÖ Conversation system active                        ‚ïë
‚ïë  ‚úÖ Dashboard running on :8080                        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);

setTimeout(showMenu, 1000);

// === GRACEFUL SHUTDOWN ===
process.on('SIGINT', () => {
  console.log('\n\n[SHUTDOWN] Saving data...');
  if (globalBot) globalBot.quit();
  process.exit(0);
});